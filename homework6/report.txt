Assignment 1

The alignment: each type's address is a multiple of its type size, so each of the varibales is aligned.
One more interesting observation about the addresses: although we initialized those with the order int->char->double->short, from the addresses we may see that they were put in the stack frame in different order double->int->short->char (stack frame grows downward, the greates address of the four variables is put first). As far as I understand the C standard does not guarantee any relative order for independent local variables. The compiler is free to place them anywhere in the frame (and even keep some in registers unless we take their address). So, I think the compiler arranged the stack frame this way to satisfy alignment and minimize padding.

OUtput:

Size of the int type is: 4 bytes
Size of the char type is: 1 bytes
Size of the double type is: 8 bytes
Size of the short type is: 2 bytes
Address of the int type is: 0x7ffe48033e4c
Address of the char type is: 0x7ffe48033e49
Address of the double type is: 0x7ffe48033e50
Address of the short type is: 0x7ffe48033e4a
Int is aligned to multiple of 4 
Char is aligned to multiple of 1 
Double is aligned to multiple of 8 
Short is aligned to multiple of 2 


Assignment 2

str 1 {char, int double}
str 2 {double, int, char}
str 3 {int, double, char}

The least number of padding in the C struct is done when the types are organized either in increasing order of their sizes (char->int->double) OR in decreasing order of their sizes (double->int->char).
So str1 and str2 have the least possible padding, and aligned properly.
In str1 we have 1 byte of char, then 3 bytes of padding, then int, then double, which makes 16 bytes in total.
In str2 we have 8 bytes double, then 4 bytes int, then 1 byte char, then 3 bytes padding, 16 byte sin total.

I added str3 just to demo what happens when the fields inside the struct are unordered (first increasing then decreasing). Its size became 24 (in contrast with str1 and str2 which have size 16) although it actually stores the same types.
The thing is that in the struct of C compiler has no right to reorganize those or put however it thinks it's optimal. So it just puts in the order those are defined aligning those correspondingly.

In str3 int address is aligned to multiple of its type alignment requirement, then double should be aligned to multiple of its type alignment requirement (multiple of _Alignof(double)). So we have int (4 bytes) then 4 bytes of padding, then double (8 bytes), then char, then 7 bytes of padding, as the struct itself has alignment max(_Alignof(int), _Alignof(char), _Alignof(double)).

To see that visually, I printed the offset of all the variables.

Output of the program:

 ***** STRUCT 1 ***** 
Size of the str1 is 16 
Address of char a in str1: 0x7ffcbe36e120 
Address of int b in str1: 0x7ffcbe36e124 
Address of double c in str1: 0x7ffcbe36e128 
 ***** STRUCT 2 ***** 
Size of the str2 is 16 
Address of double a in str1: 0x7ffcbe36e130 
Address of int b in str1: 0x7ffcbe36e138 
Address of char c in str1: 0x7ffcbe36e13c 
 ***** STRUCT 3 ***** 
Size of the str3 is 24 
Address of int a in str1: 0x7ffcbe36e140 
Address of double b in str1: 0x7ffcbe36e148 
Address of char c in str1: 0x7ffcbe36e150 


Assignment 3

Important note: I wrote all the experiments in one file restoreing the alignment configuration after each struct, so that all the outputs of the experiments are seen when running the program.
I also implemented a "safer version".
This topic was necessary for my project so I did some reading: using pragma pack() is unsafe for header files, as all the programs that include that header get that configuration of the packing, however, if packing is done via push and pop, it is not extended to the files that include that header.

So we have str1 struct which has the types in sorted order (increasing), so the padding is as few as possible: char, then 3 bytes padding, then int, then double, total: 16 bytes.

str_packed1 is done with #pragma pack(1) which tells the compiler no alignment necessary, keep the types tightly.
Then we restore that configuration with #pragma pack()

str_packed2 is done with #pragma pack(2) which tells the compiler to do the allignment to multiple of 2, so, if the type alignment requirement is less (like char which is 1), it will keep less, but if the type alignment requirement is more (like int, or double) it will decrease their alignment requirement to be multiple of 2.

The same with str_packed4 which just changes the multiple of 2 to multiple of 4.

Result:
str1: char + 3 bytes padding + int + double = 16 bytes

str_packed1: char + int + double = 1 + 4 + 8 = 13 bytes

str_packed2: char  + 1 byte padding + int + double = 1 + 1 + 4 + 8 = 14 bytes

str_packed4: char + 3 bytes padding + int + double = 1 + 3 + 4 + 8 = 16 bytes

Output:

 ***** UNPACKED STRUCT ***** 
Size of struct str1 without packing is 16 
Address of char type is 0x7ffcd2beb580
Address of int type is 0x7ffcd2beb584
Address of double type is 0x7ffcd2beb588
 ***** PACK(1) STRUCT ***** 
Size of struct str_packed1 with pack(1) is 13 
Address of char type is 0x7ffcd2beb565
Address of int type is 0x7ffcd2beb566
Address of double type is 0x7ffcd2beb56a
 ***** PACK(2) STRUCT ***** 
Size of struct str_packed2 with pack(2) is 14 
Address of char type is 0x7ffcd2beb572
Address of int type is 0x7ffcd2beb574
Address of double type is 0x7ffcd2beb578
 ***** PACK(4) STRUCT ***** 
Size of struct str_packed4 with pack(4) is 16 
Address of char type is 0x7ffcd2beb590
Address of int type is 0x7ffcd2beb594
Address of double type is 0x7ffcd2beb598

