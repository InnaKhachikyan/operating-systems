# Assignment 1

the var fork_pid stores the return value of the fork() function. If it is -1, then something went wrong, we handle that with perror, and the program returns immediately. If it is 0, then we are in the child process and print child process pid and exit with status 0. Else, we are in the parent process, we print its pid. Running the program multiple times, I noticed that first parent printing is done, then the child printing.



# Assignment 2

First we declare variables that we will need throughout the program for storing the return value of wait and waitpid, also for storing the exit status of the children.
In fork_pid we store the return value of the function fork(), if it is -1, means something went wrong, we throw a perror and return from main. If it is 0, we are in the child process, so we do printing with pid and exit with status 23. Else, if we are in the parent process, we do wait(&estatus_child1), which actually waits for ANY child, and stores its status in the pointer given as the argument.

Then we do another fork storing its return value. If it is -1, again handle with perror and return. If it is 0, we are in the child process, we do the printing with pid, and exit with status 42 (I gave these two numbers 23 and 42 just to differentiate the exit status of the children). Else, if we are in the parent process, we wait for the specific child, the second one. We specify the child by the first argument of waitpid, which is pid_t type, as fork() returns the pid of the child if we are in the parent process, I just passed the return value of the fork as the first argument to the waitpid. The second argument of the waitpid, is pointer to int, where the status of the child is stored. The last argument specifies whether to block the parent for the child to terminate or not. Which may sound contradictory, as it may seem that the main goal of waitpid should be synchronization, blocking parent until child is done, however the main goal of waitpid is to see the state change fo the child with blocking or non-blocking option, there are cases when we cannot block it until child is done, just want to reap it WHEN it is done. E.g. we have an http protocol, where parent process is polling listening to sockets, and whenever there is a request, forks, and the task of handling the http request is passed to the child. The child might take some time to finish, but the parent cannot wait for it to finish, it should continue polling. So in such cases we use waitpid with WNOHANG in a loop, just to acquire the exit status of the child if finished, not to leave zombie children, to reap them when they are done. However, if we pass 0 as the last argument, it will block the parent until the child with the given pid is done. So, I passed 0 here, to block the parent. In the parents printing I first tried to print the estatus_child directly, it turned out to be greater numbers than 23 and 42. So, it turns out that the integer filled into status by wait or waitpid packs multiple fields (signal that killed the child, core-dump flag, normal exit code etc.). When a child exits normally, the exit code is stored in the high byte of that integer. To obtain the actual status we may first check WIFEXITED(status) which returns true if child exited normally, and print the actual status with WEXITSTATUS(status). 


